<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git命令以及安全</title>
    <link href="/2025/11/26/Git%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%AE%89%E5%85%A8/"/>
    <url>/2025/11/26/Git%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Git常用命令："><a href="#Git常用命令：" class="headerlink" title="Git常用命令："></a>Git常用命令：</h3><p>git clone</p><p>克隆，也就是将远程仓库复制到本地</p><p>git push</p><p>推送，也就是将本地仓库上传到远程仓库</p><p>git pull</p><p>拉取，也就是将远程仓库代码下载到本地仓库</p><p>git status</p><p>显示当前工作目录状态，列出哪些文件有变更，哪些文件已经暂存，哪些文件没有被跟踪</p><p>git log</p><p>查看git仓库的提交历史，git会显示每次提交的哈希值，作者信息，提交日期和提交信息</p><p>git diff</p><p>显示工作区与暂存区之间的差异，就是查看文件改动的详细信息</p><p>git remove -v</p><p>显示当前项目的远程仓库信息，包括远程仓库的名称和URL地址</p><p>git pull</p><p>从远程仓库拉取最新的改动并自动合并到当前分支。若没有冲突，git会自动合并</p><p>git push</p><p>将本地分支的提交推送到远程仓库。确保本地分支与远程分支一致后，执行推送操作。</p><p>git add&amp;&amp;git commit</p><p>添加文件和提交文件</p><h2 id="Git泄露原因"><a href="#Git泄露原因" class="headerlink" title="Git泄露原因"></a>Git泄露原因</h2><h4 id="错误配置"><a href="#错误配置" class="headerlink" title="错误配置"></a>错误配置</h4><p>部署错误：开发人员将.git文件错误地放在了网站根目录下，导致它被暴露在公网上</p><p>权限错误：网站服务器的权限设置不当，导致.git文件夹可以被公开访问</p><h4 id="网站漏洞"><a href="#网站漏洞" class="headerlink" title="网站漏洞"></a>网站漏洞</h4><p>文件上传漏洞：攻击者可以利用漏洞上传恶意文件，并将其写入网站根目录下，从而床架,git文件夹</p><p>目录遍历漏洞：攻击者可以遍历网站根目录访问到,git文件</p><h4 id="工具使用不当"><a href="#工具使用不当" class="headerlink" title="工具使用不当"></a>工具使用不当</h4><p>使用了存在漏洞的git客户端或插件；这些工具可能存在安全漏洞，被攻击者利用来获取,git文件夹中的铭感信息</p><p>服务器配置错误：服务器权限错误导致.git文件可以被公开访问</p><h2 id="Git泄露在ctf中的应用"><a href="#Git泄露在ctf中的应用" class="headerlink" title="Git泄露在ctf中的应用"></a>Git泄露在ctf中的应用</h2><h4 id="常规Git泄露"><a href="#常规Git泄露" class="headerlink" title="常规Git泄露"></a>常规Git泄露</h4><p>原理：在执行git init初始化目录是，会在当前目录下自动创建一个.git目录，用来记录代码的变更记录等。如果该目录被错误的公开在网站上并且可以被访问，那么攻击者就可以利用.git中的敏感信息来恢复源代码</p><p>检测与利用：可以使用githack工具来看看网站源代码</p><h4 id="Git回滚"><a href="#Git回滚" class="headerlink" title="Git回滚"></a>Git回滚</h4><p>原理：git作为一个版本控制工具，汇集了每次提交的修改，所以当题目存在泄露时，flag 文件可能在修改中被删除或者覆盖了，这是我们可以利用 git 的 git reset 恢复到以前的版本</p><p>检测：先利用githack 获取源代码，再通过 git reset –hard NAME 命令恢复上一个版本（NAME为检测到的上一个版本名），即可获取到上一个版本的源代码。也可以使用 git log -stat 命令查看每个commit 修改了哪些文件，再利用 git diff ID-1 ID-2 比较再当前版本与想查看的commit 之间的变化</p><h4 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h4><p>原理：在每次提交时，git 都会自动把它们串成一条时间线，这条时间线就是一个分支。而 git 允许使用多个分支，从而让用户可以把工作从开发主线上分离出来，以免影响开发主线。如果没有新建分支，那么只有一条时间线，即只有一个分支，git 中默认为 master 分支。因此，我们要找的 fag 或敏感文件可能不会藏在当前分支中，这时使用“git log”命令只能找到在当前分支上的修改，并不能看到我们想要的信息，因此需要切换分支来找到想要的文件。现在大多数现成的 git 泄露工具都不支持分支，如果需要还原其他分支的代码，往往要手工进行文件的提取</p><p>检测与利用：利用githack 工具；运行命令python GitHack.py -u url&#x2F;.git ，扫描完成后会生成一个dist 文件夹。进入文件夹后执行 git log -all 或 git branch -v 命令，只能看到master 分支的信息。如果执行 git relog 命令，可以看到一些checkout 的记录，在checkout 记录中我们可能会发现其他他分支，此时工具是无法还原其它分支的信息的，需要先手动下载其他分支的head 信息保存到.git&#x2F;refs&#x2F;heads&#x2F;secret 中（执行命令 wget <a href="http://127.0.0.1:8000/.git/refs/heads/secret%EF%BC%89%E3%80%82%E5%9B%9E%E5%A4%8D">http://127.0.0.1:8000/.git/refs/heads/secret）。回复</a> head 信息后就可以在用一次 githacak，此时分支的信息就被还原了</p><h4 id="Git-日志"><a href="#Git-日志" class="headerlink" title="Git 日志"></a>Git 日志</h4><p>原理：Git的日志中包含了每次提交的详细信息，包括提交者 提交时间,提交内容等。如果这些日志泄露，攻击者可以通过分析日志来了解项目的开发历史,敏感信息的变化等。</p><p>检测与利用：可以通过访问.git&#x2F;logs&#x2F;HEAD 或 .git&#x2F;logs&#x2F;refs&#x2F;heads&#x2F;master 来查看日志内容，从中寻找可能的敏感信息</p><h4 id="Git配置文件"><a href="#Git配置文件" class="headerlink" title="Git配置文件"></a>Git配置文件</h4><p>原理：.git&#x2F;config文件中包含了仓库的配置信息，如远程仓库地址，用户信息等。如果该文件被泄露，攻击者可以获取到这些配置信息，进而有可能利用这些信息进一步入侵远程仓库或进行社工攻击</p><p>检测与利用：可以通过访问&#x2F;.git&#x2F;config文件来查看配置信息</p><h4 id="Git索引文件"><a href="#Git索引文件" class="headerlink" title="Git索引文件"></a>Git索引文件</h4><p>原理：.git&#x2F;index 文件是暂存区，记录了哪些文件被添加到了暂存区以及他们的状态。如果该文件被泄露，攻击者可以通过分析索引文件来了解哪些文件可能包含敏感信息，以及他们的版本状态</p><p>检测与利用：可以通过访问&#x2F;.git&#x2F;index 文件来获取相关信息</p><h4 id="Git钩子脚本"><a href="#Git钩子脚本" class="headerlink" title="Git钩子脚本"></a>Git钩子脚本</h4><p>原理：.git&#x2F;hooks 目录中存放了一些钩子脚本，这些脚本可以在特定的 git 操作时被触发执行。如果这些脚本被泄露，攻击者可以分析脚本内容，了解项目在特定操作时的执行逻辑，可能发现其中存在的安全隐患或敏感信息。</p><p>检测与利用：可以通过访问 .git&#x2F;hooks 目录来查看钩子脚本内容。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ctfhub</title>
    <link href="/2025/11/25/ctfhub/"/>
    <url>/2025/11/25/ctfhub/</url>
    
    <content type="html"><![CDATA[<h1 id="ctfhub-web-信息泄露-目录遍历"><a href="#ctfhub-web-信息泄露-目录遍历" class="headerlink" title="ctfhub-web-信息泄露-目录遍历"></a>ctfhub-web-信息泄露-目录遍历</h1><p>首先点击”点击开始寻找flag”，开启题目<br><img src="/2025/11/25/ctfhub/ctfhub1.png"></p><p>根据题目描述不难看出这是一道简单的套娃类型的文件题，并且给的文件夹其实比较少，只有四个文件，两层嵌套，也就是说如果一个一个点也就需要点十六下，这是一种解题方法。</p><p>也可以用python写一个脚本            </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&#x27;your_url&#x27;</span><br>response = requests.get(url)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        url_new = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;url&#125;</span><span class="hljs-subst">&#123;i&#125;</span>/<span class="hljs-subst">&#123;j&#125;</span>&#x27;</span><br>        response_new = requests.get(url_new)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;flag.txt&quot;</span> <span class="hljs-keyword">in</span> response_new.text:<br>            <span class="hljs-built_in">print</span>(url_new)<br></code></pre></td></tr></table></figure><p>这个脚本只是针对该题写的，仅供参考，输入如下：<br><img src="/2025/11/25/ctfhub/ctfhub2.png"></p><p>得到flag<br><img src="/2025/11/25/ctfhub/ctfhub4.png"></p><h1 id="ctfhub-web-信息泄露-PHPINFO"><a href="#ctfhub-web-信息泄露-PHPINFO" class="headerlink" title="ctfhub-web-信息泄露-PHPINFO"></a>ctfhub-web-信息泄露-PHPINFO</h1><p>这题没啥说的直接ctrl+F全局搜索ctfhub就能找到flag的位置<br><img src="/2025/11/25/ctfhub/ctfhub5.png"></p><h1 id="ctfhub-web-信息泄露-备份文件下载-网站源码"><a href="#ctfhub-web-信息泄露-备份文件下载-网站源码" class="headerlink" title="ctfhub-web-信息泄露-备份文件下载-网站源码"></a>ctfhub-web-信息泄露-备份文件下载-网站源码</h1><p>该题目其实和之前的目录遍历大同小异，硬算肯定是能算出来的，最多只需要试28次便能试出来</p><p>不过这边还是建议写一个脚本，也十分简单</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&#x27;your_url&#x27;</span><br><span class="hljs-keyword">end</span> = [<span class="hljs-string">&quot;tar&quot;</span>, <span class="hljs-string">&quot;tar.gz&quot;</span>, <span class="hljs-string">&quot;zip&quot;</span>, <span class="hljs-string">&quot;rar&quot;</span>]<span class="hljs-built_in"></span><br><span class="hljs-built_in">name</span> = [<span class="hljs-string">&quot;web&quot;</span>, <span class="hljs-string">&quot;website&quot;</span>, <span class="hljs-string">&quot;backup&quot;</span>, <span class="hljs-string">&quot;back&quot;</span>, <span class="hljs-string">&quot;www&quot;</span>, <span class="hljs-string">&quot;wwwroot&quot;</span>, <span class="hljs-string">&quot;temp&quot;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span><span class="hljs-built_in"> name</span>:<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> end:<br>       <span class="hljs-built_in"> path</span> = f<span class="hljs-string">&quot;&#123;i&#125;.&#123;j&#125;&quot;</span><br>        full_url = url +<span class="hljs-built_in"> path</span><br>        response = requests.get(full_url)<br>        <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>            print(f<span class="hljs-string">&quot;Found: &#123;full_url&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><p>不过下载的压缩包中确实包含了flag.txt文件，但内容似乎有点不对(感觉被耍了)<br><img src="/2025/11/25/ctfhub/"></p><p>其实下载的zip文件下的flag文件并不是我们要的信息，我们查看网页上的信息</p><p><img src="/2025/11/25/ctfhub/Users\34267\AppData\Roaming\marktext\images\2025-11-24-21-35-30-image.png"></p><p> 得到flag</p><h1 id="ctfhub-web-信息泄露-备份文件下载-bak文件"><a href="#ctfhub-web-信息泄露-备份文件下载-bak文件" class="headerlink" title="ctfhub-web-信息泄露-备份文件下载-bak文件"></a>ctfhub-web-信息泄露-备份文件下载-bak文件</h1><p>网页信息很明显了，说flag在index.php里面，而本题题目又是.bak文件，是典型的备份文件形式，因此我们直接下载index.php.bak，查看内容即可</p><p>我这边用的是记事本，得到flag<br><img src="/2025/11/25/ctfhub/ctfhub6.png"></p><h1 id="ctfhub-web-信息泄露-备份文件下载-vim"><a href="#ctfhub-web-信息泄露-备份文件下载-vim" class="headerlink" title="ctfhub-web-信息泄露-备份文件下载-vim"></a>ctfhub-web-信息泄露-备份文件下载-vim</h1><p>当工作人员在linux系统中使用vim编辑异常退出时，就会生成该文件夹下的.swp隐藏文件，该文件包含了未保存的内容</p><p>题目又给了flag在index.php文件里的提示，因此生成的swp文件极有可能是index.php的隐藏文件</p><p>因此查看&#x2F;.index.php.swp，注意：该文件是隐藏文件，因此要用&#x2F;.查看</p><p>查看后下载了相关文件，打开，发现乱码<br><img src="/2025/11/25/ctfhub/ctfhub9.png"></p><p>vim命令是linux系统下的命令，因此用windows查看肯定会乱码，这边建议使用虚拟机或者linux镜像打开，就能得到flag</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深夜反思猛做ctf喵</title>
    <link href="/2024/11/21/LISTENER/"/>
    <url>/2024/11/21/LISTENER/</url>
    
    <content type="html"><![CDATA[<h3 id="ctfshow-菜狗杯-杂项签到"><a href="#ctfshow-菜狗杯-杂项签到" class="headerlink" title="ctfshow 菜狗杯 杂项签到"></a>ctfshow 菜狗杯 杂项签到</h3><p>既然是签到题，就试探性地010打开一下，发现没什么规律<br>经过一点思考，搜索ctfshow<br>得到flag  </p><h3 id="ctfshow-菜狗杯-损坏的压缩包"><a href="#ctfshow-菜狗杯-损坏的压缩包" class="headerlink" title="ctfshow 菜狗杯 损坏的压缩包"></a>ctfshow 菜狗杯 损坏的压缩包</h3><p>嘶~<br>损坏的压缩包，可能格式存在错误<br>用010打开一下，发现开头是PNG<br>有可能是图片格式错误<br>修改格式<br>得到flag   </p><h3 id="ctfshow-菜狗杯-你会数数么"><a href="#ctfshow-菜狗杯-你会数数么" class="headerlink" title="ctfshow 菜狗杯 你会数数么"></a>ctfshow 菜狗杯 你会数数么</h3><p>老规矩010打开，发现一堆没有规律的文本<br>试探性搜索ctf<br>结果发现是”c””t””f”字母个数连续<br>结合题目，猜测是根据字母个数排序<br>010排序得到flag   </p><h3 id="ctfshow-菜狗杯-我是谁"><a href="#ctfshow-菜狗杯-我是谁" class="headerlink" title="ctfshow 菜狗杯 我是谁"></a>ctfshow 菜狗杯 我是谁</h3><p><img src="/2024/11/21/LISTENER/22.jpg" alt="这是图片" title="question"><br>嘶<br>越看越不对劲，这我也没玩过宝可梦呀<br>右键打开源代码<br>一堆美铝<br>看三十个得到ctf<br>这种题下次多出点</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
